fg_milk = fg_milk/100,
fg_oils = fg_oils/100,
fg_sweets = fg_sweets/100,
fg_veggie = fg_veggie/100) %>%
mutate(inten_non = if_else(intensity == 'nonablative', 1, 0),
inten_ab = if_else(intensity == 'ablative', 1, 0),
inten_re = if_else(intensity == 'reduced', 1, 0))
cts <- read_csv('../data/cleaned_stool/ALL_stool_samples_family_counts.csv') %>%
filter(sampleid %in% meta$sampleid) %>%
dplyr::select(sampleid, taxa_family, relab) %>%
mutate(taxa_family = str_extract(taxa_family, 'f__.+$')) %>%
mutate(taxa_family = str_replace(taxa_family, 'f__','')) %>%
filter(taxa_family != 'NA')
thre <- seq(0.0001, 0.003, 0.0001)
thre %>%
set_names(thre) %>%
map_dfr(function(num){
cts %>%
group_by(taxa_family) %>%
count(relab > num) %>%
rename(criteria = names(.)[2]) %>%
filter(criteria == 'TRUE') %>%
arrange(-n) %>%
mutate(perc = round(n/nrow(meta)*100, 0)) %>%
filter(perc > 10) %>%
nrow
}) %>%
gather('thre', 'num')
# choose 0.002
target_family <-  cts %>%
group_by(taxa_family) %>%
count(relab > 0.002) %>%
rename(criteria = names(.)[2]) %>%
filter(criteria == 'TRUE') %>%
arrange(-n) %>%
mutate(perc = round(n/nrow(meta)*100, 0)) %>%
filter(perc > 10) %>%
pull(taxa_family)
domcts <- cts %>%
filter(taxa_family %in% target_family) %>%
mutate(relablog = log10(relab + 2*10^-6)) %>%
dplyr::select(-relab) %>%
spread(key = 'taxa_family', value = 'relablog')
All <- domcts %>%
full_join(meta, by = "sampleid")
# getting to know the distributionn of the family relab log
domcts_narrow <- cts %>%
filter(taxa_family %in% target_family) %>%
mutate(relablog = log10(relab + 2*10^-6)) %>%
dplyr::select(-relab)
range(domcts_narrow$relablog) # 0 , -5.7
priors <- c(# for the food group variables
prior(normal(0, 1.2), class = 'b', coef = "fg_egg"),
prior(normal(0, 1.2), class = 'b', coef = "fg_fruit"),
prior(normal(0, 1.2), class = 'b', coef = "fg_grain"),
prior(normal(0, 1.2), class = 'b', coef = "fg_legume"),
prior(normal(0, 1.2), class = 'b', coef = "fg_meat"),
prior(normal(0, 1.2), class = 'b', coef = "fg_milk"),
prior(normal(0, 1.2), class = 'b', coef = "fg_oils"),
prior(normal(0, 1.2), class = 'b', coef = "fg_sweets"),
prior(normal(0, 1.2), class = 'b', coef = "fg_veggie"),
# for the TPN
prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE"),
# for the EN
prior(normal(0, 0.1), class = 'b', coef = "ENTRUE"),
# for the empirical
prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE"),
# for the intensity
prior(normal(0, 0.1), class = 'b', coef = "inten_re"),
prior(normal(0, 0.1), class = 'b', coef = "inten_ab"),
prior(normal(0, 0.1), class = 'b', coef = "inten_non"),
prior(normal(-3, 1), class = 'Intercept'))
model_formular <- Bacteroidaceae ~ 1 +
fg_fruit+
fg_meat+
fg_milk+
fg_oils+
fg_egg+
fg_grain+
fg_sweets+
fg_legume+
fg_veggie+
inten_non + inten_ab + inten_re +
empirical+
TPN+
EN+
(1 | mrn) +
(1 | timebin)
# the usual model
model_old <- brm( model_formular,
data = All,
warmup = 1000, iter = 3000,
prior = priors,
cores = ncores,
chains = 2,
control = list(adapt_delta = 0.99),
seed = 123, sample_prior = T )
# prior check
# mean_fg <-  meta %>%
#   select(starts_with('fg')) %>%
#   summarise_all(funs(mean))
#
# samples_prior <- prior_samples(model_old)
#
# ave_each_fg <- samples_prior %>%
#   mutate(mean_fg = Intercept +
#            b_fg_fruit*mean_fg$fg_fruit +
#            b_fg_meat*mean_fg$fg_meat +
#            b_fg_milk*mean_fg$fg_milk +
#            b_fg_oils*mean_fg$fg_oils +
#            b_fg_egg*mean_fg$fg_egg +
#            b_fg_grain*mean_fg$fg_grain +
#            b_fg_sweets*mean_fg$fg_sweets +
#            b_fg_legume*mean_fg$fg_legume +
#            b_fg_veggie*mean_fg$fg_veggie +
#            b_inten_re +
#            b_empiF +
#            b_tpnF +
#            b_enF) %>%
#   select(mean_fg) %>%
#   mutate(grp = 'ave_each') %>%
#   rename(prior_res = mean_fg) %>%
#   select(grp, prior_res)
#
# ave_each_fg %>%
#   gghistogram(x = 'prior_res')
#
# ave_each_fg %>%
#   count(prior_res >-5.7 & prior_res<0) %>%
#   mutate(perc = n/4000*100) %>%
#   select(perc) %>%
#   slice(2) %>%
#   pull(perc) %>%
#   round(1)
# wannt to do the above for every family I'm going to run
# so basically run every model and extract the priors later
## all family model run
ret <- target_family %>%
set_names(target_family) %>%
map(function(fam) {
mod =  brm( as.formula(str_glue('{fam}  ~
1 +
fg_fruit+
fg_meat+
fg_milk+
fg_oils+
fg_egg+
fg_grain+
fg_sweets+
fg_legume+
fg_veggie+
inten_non + inten_ab + inten_re +
empirical+
TPN+
EN+
(1 | mrn) +
(1 | timebin)')),
data = All,
warmup = 1000, iter = 3000,
prior = priors,
cores = ncores,
chains = 2,
control = list(adapt_delta = 0.99),
seed = 456, sample_prior = T)
})
View(All)
# wannt to do the above for every family I'm going to run
# so basically run every model and extract the priors later
## all family model run
ret <- target_family %>%
set_names(target_family) %>%
purrr::map(function(fam) {
mod =  brm( as.formula(str_glue('{fam}  ~
1 +
fg_fruit+
fg_meat+
fg_milk+
fg_oils+
fg_egg+
fg_grain+
fg_sweets+
fg_legume+
fg_veggie+
inten_non + inten_ab + inten_re +
empirical+
TPN+
EN+
(1 | mrn) +
(1 | timebin)')),
data = All,
warmup = 1000, iter = 3000,
prior = priors,
cores = ncores,
chains = 2,
control = list(adapt_delta = 0.99),
seed = 456, sample_prior = T)
})
source("~/Downloads/MSK/MSS_pipeline-/scripts/database_related/create_new_postgres_user_vbdlab.R", echo=TRUE)
#Oct/22/2019
#
#Create username specific access to database in VDB lab.
#It removes the general `guest` account.
#
#
#Dropping user:
#  drop owned by test; drop role test; (https://stackoverflow.com/questions/9840955/postgresql-drop-role-fails-because-of-default-privileges)
#
#In order to set a new password, users need to run the following command:
#dbSendQuery(conn = con,"alter role YOUR_USERNAME password 'YOUR_PASSWORD'");
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# when there is request for new connection, add the new username to the list downbelow
# after the person changed the password, run this script again to unlock this user. then he should be good to go.
# (if the person doesn't change pw within 3 days), run :
#dbSendQuery(conn = con, "drop owned by <user>; drop role <user>")
#to drop the user
# (run this script and look down below to check who changed and who didn't  )
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
library(DBI)
source('create_new_postgres_user.R');
vdb_users <- c("peledj",
"burgosdm",
"docampom",
"slingerj",
"nguyenc1",
"daia1",
"markeyk",
"armijog",
"miltiado",
"andrlovh",
"lindners",
"breretod",
"giardinp",
"khann2",
"zuanellc",
"hatfielp",
"clurmana",
"smithm4",
#"test_user"
"adintorp",
"ngb",
"chens8",
"elkriefa",
"mab4025",
"harfordl",
"jesusfar",
"crossj",
'funnellt',
"watersn",
"maclachlan",
"feit1",
"rajs");
#               "gomesa_cluster");
collaboration_users <- c("shouvalr",
"lesokhia",
"rollingt",
"chowelld",
"krishnac");
#temporary_pw=my.name <- readline(prompt="Enter temporary password: ")
temporary_pw='test123456';
vdb_and_collaborator_users <- c(vdb_users,
collaboration_users);
#stop("Stopping before creating user");
for(i in 1:length(vdb_and_collaborator_users)){
create_new_postgres_user(vdb_and_collaborator_users[i],temporary_pw);
}
cat("\n\n")
#create_new_postgres_user(vdb_users[length(vdb_users)],temporary_pw);
if(1){
#Run this part to remove passwords!
for(i in 1:length(vdb_and_collaborator_users)){
block_user_who_did_not_change_password(vdb_and_collaborator_users[i],
temporary_pw)
}
}
#block_user_who_did_not_change_password(vdb_users[length(vdb_users)],temporary_pw);
# save the data
prior_df <- ret %>%
imap(~ prior_draws(.x) ) %>%
bind_rows(.id = .y)
# save the data
prior_df <- ret %>%
imap(~ prior_draws(.x) )
View(prior_df)
# save the data
prior_df <- ret %>%
imap(~ prior_draws(.x) ) %>%
bind_rows(.id = 'family')
View(prior_df)
prior_df %>%
write_csv('../data/054_family_model_prior.csv')
post_df <- ret %>%
imap(~ (suppressWarnings(posterior_samples(.x)) %>%
select(starts_with('b_fg')) %>%
gather('item','coeff') %>%
mutate(family = .y)))  %>%
bind_rows()
View(post_df)
post_df <- ret %>%
imap(~ (suppressWarnings(posterior_samples(.x))))  %>%
bind_rows(.id = 'family')
View(post_df)
post_df <- ret %>%
imap(~ (suppressWarnings(posterior_samples(.x)) %>%
select(-starts_with('r_mrn'))))  %>%
bind_rows(.id = 'family')
post_df <- ret %>%
imap(~ (suppressWarnings(posterior_samples(.x)) %>%
select(-starts_with('r_'))))  %>%
bind_rows(.id = 'family')
post_df <- ret %>%
imap(~ (suppressWarnings(posterior_samples(.x)) %>%
select(-starts_with('r_'))))  %>%
bind_rows(.id = 'family')
post_df %>%
write_csv('../data/054_family_model_post.csv')
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
# grab the quantiles for the 95% and 75% confidence interval from the posterior samples
post_df <- read_csv('../data/054_family_model_post.csv')
# grab the quantiles for the 95% and 75% confidence interval from the posterior samples
post_df <- read_csv('../data/054_family_model_post.csv')
# grab the quantiles for the 95% and 75% confidence interval from the posterior samples
post_df <- read_csv('../data/054_family_model_post.csv')
post_df %>%
select(starts_with('b_fg'))
post_res <- post_df %>%
select(starts_with('b_fg'))
View(post_res)
post_res <- post_df %>%
select(starts_with('b_fg')) %>%
gather('item','coeff') %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875)) %>%
ungroup() %>%
mutate(sig = if_else(q97.5 < 0 | q2.5 > 0, T, F)) %>%
mutate(mark = if_else(sig == T, '*','')) %>%
mutate(color = if_else(q87.5 < 0, 'steelblue', if_else(q12.5 > 0, 'maroon', 'white'))) %>%
mutate(family = str_replace(family, '._Incertae_Sedis','')) %>%
mutate(item = str_replace(item, 'b_fg_',''))
View(post_df)
post_res <- post_df %>%
select(family, starts_with('b_fg'))
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)])
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)])
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)]) %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875)) %>%
ungroup() %>%
mutate(sig = if_else(q97.5 < 0 | q2.5 > 0, T, F)) %>%
mutate(mark = if_else(sig == T, '*','')) %>%
mutate(color = if_else(q87.5 < 0, 'steelblue', if_else(q12.5 > 0, 'maroon', 'white'))) %>%
mutate(family = str_replace(family, '._Incertae_Sedis','')) %>%
mutate(item = str_replace(item, 'b_fg_',''))
100-97.5
2.5/2
100-1.25
1.25/100
0.5/100
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)]) %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875),
q1.25 = quantile(coeff, probs = 0.0125),
q98.75 = quantile(coeff, probs = 0.9875),
q0.5 = quantile(coeff, probs = 0.005),
q99.5 = quantile(coeff, probs = 0.995)
) %>%
ungroup() %>%
#mutate(sig = if_else(q97.5 < 0 | q2.5 > 0, T, F)) %>%
mutate(mark = if_else(q99.5 < 0 | q0.5 > 0, '***', if_else(q98.75 < 0 | q1.25 > 0, '**', if_else(q97.5 < 0 | q2.5 > 0, '*', ''))))
post_df <- read_csv('../data/054_family_model_post.csv')
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)]) %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875),
q1.25 = quantile(coeff, probs = 0.0125),
q98.75 = quantile(coeff, probs = 0.9875),
q0.5 = quantile(coeff, probs = 0.005),
q99.5 = quantile(coeff, probs = 0.995)
)
# grab the quantiles for the 95% (star) and 75% (color) confidence interval from the posterior samples
# two stars for 97.5% and three stars for 99%
post_df <- read_csv('../data/054_family_model_post.csv')
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)]) %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875),
q1.25 = quantile(coeff, probs = 0.0125),
q98.75 = quantile(coeff, probs = 0.9875),
q0.5 = quantile(coeff, probs = 0.005),
q99.5 = quantile(coeff, probs = 0.995)
) %>%
ungroup() %>%
mutate(mark = if_else(q99.5 < 0 | q0.5 > 0, '***', if_else(q98.75 < 0 | q1.25 > 0, '**', if_else(q97.5 < 0 | q2.5 > 0, '*', '')))) %>%
mutate(color = if_else(q87.5 < 0, 'steelblue', if_else(q12.5 > 0, 'maroon', 'white'))) %>%
mutate(family = str_replace(family, '._Incertae_Sedis','')) %>%
mutate(item = str_replace(item, 'b_fg_',''))
# grab the quantiles for the 95% (star) and 75% (color) confidence interval from the posterior samples
# two stars for 97.5% and three stars for 99%
post_df <- read_csv('../data/054_family_model_post.csv')
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)]) %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875),
q1.25 = quantile(coeff, probs = 0.0125),
q98.75 = quantile(coeff, probs = 0.9875),
q0.5 = quantile(coeff, probs = 0.005),
q99.5 = quantile(coeff, probs = 0.995)
) %>%
ungroup() %>%
mutate(mark = if_else(q99.5 < 0 | q0.5 > 0, '***', if_else(q98.75 < 0 | q1.25 > 0, '**', if_else(q97.5 < 0 | q2.5 > 0, '*', '')))) %>%
mutate(color = if_else(q87.5 < 0, 'steelblue', if_else(q12.5 > 0, 'maroon', 'white'))) %>%
mutate(family = str_replace(family, '._Incertae_Sedis','')) %>%
mutate(item = str_replace(item, 'b_fg_',''))
# grab the quantiles for the 95% (star) and 75% (color) confidence interval from the posterior samples
# two stars for 97.5% and three stars for 99%
post_df <- read_csv('../data/054_family_model_post.csv')
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)]) %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875),
q1.25 = quantile(coeff, probs = 0.0125),
q98.75 = quantile(coeff, probs = 0.9875),
q0.5 = quantile(coeff, probs = 0.005),
q99.5 = quantile(coeff, probs = 0.995)
) %>%
ungroup() %>%
mutate(mark = if_else(q99.5 < 0 | q0.5 > 0, '***', if_else(q98.75 < 0 | q1.25 > 0, '**', if_else(q97.5 < 0 | q2.5 > 0, '*', '')))) %>%
mutate(color = if_else(q87.5 < 0, 'steelblue', if_else(q12.5 > 0, 'maroon', 'white'))) %>%
mutate(family = str_replace(family, '._Incertae_Sedis','')) %>%
mutate(item = str_replace(item, 'b_fg_',''))
# grab the quantiles for the 95% (star) and 75% (color) confidence interval from the posterior samples
# two stars for 97.5% and three stars for 99%
post_df <- read_csv('../data/054_family_model_post.csv')
post_res <- post_df %>%
select(family, starts_with('b_fg')) %>%
gather('item','coeff', names(.)[2]:names(.)[ncol(.)]) %>%
group_by(family, item) %>%
summarise(q50 = median(coeff),
q2.5 = quantile(coeff, probs = 0.025),
q97.5 = quantile(coeff, probs = 0.975),
q12.5 = quantile(coeff, probs = 0.125),
q87.5 = quantile(coeff, probs = 0.875),
q1.25 = quantile(coeff, probs = 0.0125),
q98.75 = quantile(coeff, probs = 0.9875),
q0.5 = quantile(coeff, probs = 0.005),
q99.5 = quantile(coeff, probs = 0.995)
) %>%
ungroup() %>%
mutate(mark = if_else(q99.5 < 0 | q0.5 > 0, '***', if_else(q98.75 < 0 | q1.25 > 0, '**', if_else(q97.5 < 0 | q2.5 > 0, '*', '')))) %>%
mutate(color = if_else(q87.5 < 0, 'steelblue', if_else(q12.5 > 0, 'maroon', 'white'))) %>%
mutate(family = str_replace(family, '._Incertae_Sedis','')) %>%
mutate(item = str_replace(item, 'b_fg_',''))
col_key <- post_res %>%
ungroup() %>%
distinct(color) %>%
pull(color)
names(col_key) <- col_key
ggplot(post_res, aes(x = item, y = family)) +
geom_tile(aes(fill = color,  x = item,y =  family), alpha = 0.5, color='white', width=0.95, height=0.95) +
# geom_text(aes(label = round(meanperitem, 3))) +
geom_text(aes(label = mark, x = item,y =  family),
nudge_y = -0.3, nudge_x = 0,size = 8) +
scale_fill_manual(values = col_key, labels = c('Effects too small','75% CI < 0 negative','75% CI > 0 positive')) +
theme_light() +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
#panel.grid.major = element_blank(),
#panel.grid.minor = element_blank(),
legend.position = 'bottom',
legend.key = element_rect( colour = "gray50"),
panel.background = element_blank())
ggsave('../figs/paper/heatmap_family_24_ggplot.pdf', width = 7, height = 5)
