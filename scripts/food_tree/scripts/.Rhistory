select(key, value) %>%
group_by(key) %>%
summarise(q2.5 = quantile(value, probs = 0.025),
q97.5 = quantile(value, probs = 0.975),
q17 = quantile(value, probs = 0.17),
q83 = quantile(value, probs = 0.83),
q50 = quantile(value, probs = 0.5)) %>%
filter(str_detect(key, '^r')) %>%
select(key, q2.5,q17, q50, q83,  q97.5)
kbl(revised_post) %>%
kable_classic(full_width = F, html_font = "Arial")%>%
save_kable(file = "../figs/paper/T2_main_model_random_effects.pdf")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(cowplot)
library(ggpubr)
combined <- read_csv('../data/growth/069_irep_combined_res.csv')
meta <- read_csv('../data/cleaned_stool/all_samples_meta_p2d_fg9_updated.csv')
key <- read_csv('../data/cleaned_diet_data/food_group_color_key_final.csv', col_types = 'ccccc') %>%
select(fg = fg1_name,shortname )
scatter_alpha <- 0.35
cor_text_size <- 3
axis_text_size <- 11
axis_title_size <- 11
# the median of the fruits
median6 <- median(combined$fg_fruit)
median9 <- median(combined$fg_sweets)
tbt_ent <- bind_rows(
combined %>%
filter(str_detect(best_species, 'Enterococcus')) %>%
group_by(sampleid) %>%
summarise(ave_irep = mean(aveirep)) %>%
inner_join(meta) %>%
mutate(grp = 'Enterococcus only'),
combined %>%
filter(!str_detect(best_species, 'Enterococcus')) %>%
group_by(sampleid) %>%
summarise(ave_irep = mean(aveirep)) %>%
inner_join(meta) %>%
mutate(grp = 'All taxa excl. Enterococcus')
) %>%
select(sampleid, ave_irep, grp, fg_sweets, fg_fruit ) %>%
gather('fg', 'gram', fg_sweets:fg_fruit) %>%
mutate(grp = factor(grp, levels = c('Enterococcus only','All taxa excl. Enterococcus'))) %>%
left_join(key)
tbt_ent_f <- tbt_ent %>% filter(shortname == 'Fruits') %>%
mutate(tier = if_else(gram >= median6, 'higher', 'lower'))
t3a_box <- tbt_ent_f  %>%
ggboxplot(x = 'tier', y = 'ave_irep', alpha = scatter_alpha,
xlab = 'Fruits intake in previous 2 days (g)',
ylab = 'Average growth rate\n(iRep estimation)') +
facet_grid(. ~ grp) +
theme_classic() +
stat_compare_means(comparisons= list(c('higher', 'lower')),
label= "p.signif",
method= 'wilcox.test',
correct=FALSE) +
theme(plot.background = element_blank(),
aspect.ratio = 1,
axis.text=element_text(size=axis_text_size),
axis.title=element_text(size=axis_title_size),
plot.title = element_text(size=axis_title_size),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.text.x = element_text(size = 8))
# I want the top row and bottom row to have different x scales.
t3a <- tbt_ent_f  %>%
ggscatter(x = 'gram', y = 'ave_irep', alpha = scatter_alpha,
xlab = 'Fruits intake in previous 2 days (g)',
ylab = 'Average growth rate\n(iRep estimation)',
add = "reg.line",
add.params = list(color = "blue", fill = "lightgray"), # Customize line
conf.int = TRUE,
cor.coef = TRUE,
cor.coeff.args = list(method = "spearman",  label.sep = ",   ", size = cor_text_size)) +
facet_grid(. ~ grp) +
theme_classic() +
theme(plot.background = element_blank(),
aspect.ratio = 1,
axis.text=element_text(size=axis_text_size),
axis.title=element_text(size=axis_title_size),
plot.title = element_text(size=axis_title_size),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.text.x = element_text(size = 8))
b3a <- tbt_ent %>% filter(shortname == 'Sweets') %>%
ggscatter(x = 'gram', y = 'ave_irep', alpha = scatter_alpha,
xlab = 'Sweets intake in previous 2 days (g)',
ylab = '',
add = "reg.line",
add.params = list(color = "blue", fill = "lightgray"), # Customize line
conf.int = TRUE,
cor.coef = TRUE,
cor.coeff.args = list(method = "spearman",  label.sep =",   ", size = cor_text_size)) +
facet_grid(. ~ grp) +
theme_classic() +
theme( plot.background = element_blank(),
aspect.ratio = 1,
axis.text=element_text(size=axis_text_size),
axis.title=element_text(size=axis_title_size),
plot.title = element_text(size=axis_title_size),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.text.x = element_text(size = 8))
tbt_kle <- bind_rows(
combined %>%
filter(str_detect(best_species, 'Klebsiella')) %>%
group_by(sampleid) %>%
summarise(ave_irep = mean(aveirep)) %>%
inner_join(meta) %>%
mutate(grp = 'Klebsiella only'),
combined %>%
filter(!str_detect(best_species, 'Klebsiella')) %>%
group_by(sampleid) %>%
summarise(ave_irep = mean(aveirep)) %>%
inner_join(meta) %>%
mutate(grp = 'All taxa excl. Klebsiella')
) %>%
select(sampleid, ave_irep, grp, fg_sweets, fg_fruit ) %>%
gather('fg', 'gram', fg_sweets:fg_fruit) %>%
mutate(grp = factor(grp, levels = c('Klebsiella only','All taxa excl. Klebsiella'))) %>%
left_join(key)
# I want the top row and bottom row to have different x scales.
t3b <- tbt_kle %>% filter(shortname == 'Fruits') %>%
ggscatter(x = 'gram', y = 'ave_irep', alpha = scatter_alpha,
xlab = 'Fruits intake in previous 2 days (g)',
ylab = 'Average growth rate\n(iRep estimation)',
add = "reg.line",
add.params = list(color = "blue", fill = "lightgray"), # Customize line
conf.int = TRUE,
cor.coef = TRUE,
cor.coeff.args = list(method = "spearman",  label.sep = ",   ", size = cor_text_size)) +
facet_grid(. ~ grp) +
theme_classic() +
theme(plot.background = element_blank(),
aspect.ratio = 1,
axis.text=element_text(size=axis_text_size),
axis.title=element_text(size=axis_title_size),
plot.title = element_text(size=axis_title_size),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.text.x = element_text(size = 8))
b3b <- tbt_kle %>% filter(shortname == 'Sweets') %>%
ggscatter(x = 'gram', y = 'ave_irep', alpha = scatter_alpha,
xlab = 'Sweets intake in previous 2 days (g)',
ylab = '',
add = "reg.line",
add.params = list(color = "blue", fill = "lightgray"), # Customize line
conf.int = TRUE,
cor.coef = TRUE,
cor.coeff.args = list(method = "spearman",  label.sep = ",   ", size = cor_text_size )) +
facet_grid(. ~ grp) +
theme_classic() +
theme(
plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
aspect.ratio = 1,
axis.text=element_text(size=axis_text_size),
axis.title=element_text(size=axis_title_size),
plot.title = element_text(size=axis_title_size),
strip.text.x = element_text(size = 8))
# assemble the top and bottom of 3b
f3b <- plot_grid(t3b, b3b,
byrow = T,
ncol = 1, axis = 'ltbr', align = 'hv', rel_widths = c(1, 1))
# decided to just use the enterococcus and fruit & klebsiella with sweets
ent_fruit <- tbt_ent %>%
filter(shortname == 'Fruits' & grp == 'Enterococcus only')
# calculate the p value of the slope of the regression line
res_ent_fruit <- summary(lm(ave_irep ~ gram, data = ent_fruit ))
ent_fruit_p <- round(res_ent_fruit$coefficients[2, 'Pr(>|t|)'], 2)
f3a <- ent_fruit %>%
ggscatter(x = 'gram', y = 'ave_irep', alpha = scatter_alpha, shape = 16,
xlab = 'Fruits intake in\nprevious 2 days (g)',
ylab = 'Growth rate',
title = 'Enterococcus',
add = "reg.line",
add.params = list(color = "blue", fill = "lightgray"), # Customize line
conf.int = TRUE) +
annotate("text", x = 40, y = 1, label = str_glue("paste(italic(p), \" = {ent_fruit_p}\")"), parse = TRUE) +
theme_classic() +
theme(
plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
aspect.ratio = 1,
axis.text=element_text(size=axis_text_size),
axis.title=element_text(size=axis_title_size),
plot.title = element_text(size=axis_title_size),
strip.text.x = element_text(size = 8))
f3a
ggsave('../figs/paper/094_f3a.pdf',
width = 60,
height = 60,
#height = 60,
units = c("mm"),
dpi = 400, plot = f3a)
f3a %>% write_rds('../data/094_f3a.rds')
# klebsiella with sweets
kle_sweet <- tbt_kle %>%
filter(shortname == 'Sweets' & grp == 'Klebsiella only')
# calculate the p value of the slope of the regression line
res_kle_sweet <- summary(lm(ave_irep ~ gram, data = kle_sweet ))
kle_sweet_p <- round(res_kle_sweet$coefficients[2, 'Pr(>|t|)'], 2)
f3b <- kle_sweet %>%
ggscatter(x = 'gram', y = 'ave_irep', alpha = scatter_alpha, shape = 16,
xlab = 'Sweets intake in\nprevious 2 days (g)',
ylab = 'Growth rate',
title = 'Klebsiella',
add = "reg.line",
add.params = list(color = "blue", fill = "lightgray"), # Customize line
conf.int = TRUE) +
annotate("text", x = 75, y = 1, label = str_glue("paste(italic(p), \" = {kle_sweet_p}\")"), parse = TRUE) +
theme_classic() +
theme(
plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
aspect.ratio = 1,
axis.text=element_text(size=axis_text_size),
axis.title=element_text(size=axis_title_size),
plot.title = element_text(size=axis_title_size),
strip.text.x = element_text(size = 8))
ggsave('../figs/paper/094_f3b.pdf',
width = 60,
height = 60,
#height = 60,
units = c("mm"),
dpi = 400, plot = f3b)
f3b %>% write_rds('../data/094_f3b.rds')
spp <- combined %>%
count(best_species, best_level) %>%
filter(!best_level %in% c('superkingdom', 'family')) %>%
mutate(cleaned_genus = str_replace(best_species, '^\\[',''),
cleaned_genus = str_replace(cleaned_genus, '\\]','')) %>%
mutate(cleaned_genus = str_replace(cleaned_genus, ' .+$',''))
c_genus <- spp %>%
count(cleaned_genus)
genus_combined <- combined %>%
inner_join(spp %>%
select(best_species, cleaned_genus)) %>%
add_count(cleaned_genus) %>%
# remove the genus as singletons
filter(n > 1) %>%
mutate(xlabel = str_glue('{cleaned_genus} ({n})')) %>%
mutate(xlabel = fct_reorder(xlabel, aveirep, .fun=median, .desc = T))
genus_combined %>%
ungroup() %>%
ggviolin(x = 'xlabel', y = 'aveirep', add = 'boxplot',xlab = 'Genus',
ylab = 'Average irep value',
#add.params = list(alpha = 0.5)
)
ggsave('../figs/paper/S10_genus_irep_histogram_094_Jan25.pdf', width = 320, height = 120, units = 'mm', dpi = 400)
spp <- combined %>%
count(best_species, best_level) %>%
filter(!best_level %in% c('superkingdom', 'family')) %>%
mutate(cleaned_genus = str_replace(best_species, '^\\[',''),
cleaned_genus = str_replace(cleaned_genus, '\\]','')) %>%
mutate(cleaned_genus = str_replace(cleaned_genus, ' .+$',''))
c_genus <- spp %>%
count(cleaned_genus)
genus_combined <- combined %>%
inner_join(spp %>%
select(best_species, cleaned_genus)) %>%
add_count(cleaned_genus) %>%
# remove the genus as singletons
filter(n > 1) %>%
mutate(xlabel = str_glue('{cleaned_genus} ({n})')) %>%
mutate(xlabel = fct_reorder(xlabel, aveirep, .fun=median, .desc = T))
genus_combined %>%
ungroup() %>%
ggviolin(x = 'xlabel', y = 'aveirep', add = 'boxplot',xlab = 'Genus',
ylab = 'Average irep value',
#add.params = list(alpha = 0.5)
) +
theme(
axis.text.x = element_text(angle=90, hjust=1)
)
ggsave('../figs/paper/S10_genus_irep_histogram_094_Jan25.pdf', width = 320, height = 120, units = 'mm', dpi = 400)
genus_combined %>%
ungroup() %>%
ggviolin(x = 'xlabel', y = 'aveirep', add = 'boxplot',xlab = 'Genus',
ylab = 'Average irep value',
#add.params = list(alpha = 0.5)
) +
theme(
axis.text.x = element_text(angle=180, hjust=1)
)
spp <- combined %>%
count(best_species, best_level) %>%
filter(!best_level %in% c('superkingdom', 'family')) %>%
mutate(cleaned_genus = str_replace(best_species, '^\\[',''),
cleaned_genus = str_replace(cleaned_genus, '\\]','')) %>%
mutate(cleaned_genus = str_replace(cleaned_genus, ' .+$',''))
c_genus <- spp %>%
count(cleaned_genus)
genus_combined <- combined %>%
inner_join(spp %>%
select(best_species, cleaned_genus)) %>%
add_count(cleaned_genus) %>%
# remove the genus as singletons
filter(n > 1) %>%
mutate(xlabel = str_glue('{cleaned_genus} ({n})')) %>%
mutate(xlabel = fct_reorder(xlabel, aveirep, .fun=median, .desc = T))
genus_combined %>%
ungroup() %>%
ggviolin(x = 'xlabel', y = 'aveirep', add = 'boxplot',xlab = 'Genus',
ylab = 'Average irep value',
#add.params = list(alpha = 0.5)
) +
theme(
axis.text.x = element_text(angle=270, hjust=1)
)
ggsave('../figs/paper/S10_genus_irep_histogram_094_Jan25.pdf', width = 320, height = 120, units = 'mm', dpi = 400)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyverse)
library(vdbR)
library(ggpubr)
connect_database('~/dbConfig.txt')
get_table_from_database("asv_annotation_blast_color_ag");
counts_data <- get_counts_subset(c('3115A'))
View(counts_data)
dat <- counts_data %>%
select(asv_key:count_total, count_relative)
View(dat)
dat <- counts_data %>%
select(asv_key:count_total, count_relative) %>%
left_join(asv_annotation_blast_color_ag %>%
select(asv_key,color_label_group_distinct), by = "asv_key")
# there are some ASVs that don't have a color with it, but can use the color for the genus level
color_group <- dat %>%
split(is.na(.$color_label_group_distinct))
# find the genus for these asv
get_table_from_database('asv_annotation_blast_ag')
no_color <- color_group %>%
pluck('TRUE') %>%
distinct(asv_key) %>%
inner_join(asv_annotation_blast_ag %>%
select(asv_key, genus))
# find the colors for these genera
genera_colors <- no_color %>%
distinct(genus) %>%
inner_join(asv_annotation_blast_color_ag %>%
distinct(genus, color_label_group_distinct))
# the full df for the no color genera
no_color_df <- no_color %>%
left_join(genera_colors)
no_color_df_full <- color_group %>%
pluck('TRUE') %>%
select(-color_label_group_distinct) %>%
left_join(no_color_df %>%
select(- genus))
# so if the genus is unknown then it's gonna be assigned "other" gray color
# the question is do we go one taxa level higher or make a new color base and shades for the new asv
# after discussing with Tsoni, we decided that it's ok to assign gray to the unknown genus
# merge the new no_color_df_full to the original df
dat <- bind_rows(
no_color_df_full,
color_group %>%
pluck('FALSE')
)
asv_color_set <- asv_annotation_blast_color_ag %>%
distinct(color,color_label_group_distinct,color_label_group,color_base) %>%
select(color_label_group_distinct, color) %>%
deframe()
cbd <- compute_beta_diversity_and_tsne(sampleid = dat$sampleid,
taxonomy = dat$color_label_group_distinct,
count = dat$count);
#compute beta diversity
cbd$compute_beta_diversity()
stacked_bar <- ggplot(dat,aes(sampleid, count_relative, fill = color_label_group_distinct) ) +
geom_bar(stat = "identity", position="fill", width = 1) +
theme_classic() +
labs(title = '',
ylab = 'Relative counts') +
theme(axis.text.x = element_text(angle = 90),
axis.text.y = element_blank(),
legend.position = "none") +
scale_fill_manual(values = asv_color_set)
stacked_bar
p <- '../data/composition_legend.png'
# there are some ASVs that don't have a color with it, but can use the color for the genus level
color_group <- dat %>%
split(is.na(.$color_label_group_distinct))
# find the genus for these asv
get_table_from_database('asv_annotation_blast_ag')
no_color <- color_group %>%
pluck('TRUE') %>%
distinct(asv_key) %>%
inner_join(asv_annotation_blast_ag %>%
select(asv_key, genus))
library(cowplot)
p <- '../data/composition_legend.png'
diagram <- ggdraw() +
draw_image(magick::image_read(p),   scale = 0.9)
diagram
p <- '../data/composition_legend.png'
legend <- ggdraw() +
draw_image(magick::image_read(p),   scale = 0.9)
legend
top <- plot_grid(stacked_bar, legend, labels = 'none',rel_widths  = c(1, 2) )
top
ggsave('../data/bar_3115A.pdf',
width = 190,
height = 120,
#height = 60,
units = c("mm"),
dpi = 400, plot = top)
spp <- readxl::read_excel('../data/top20_species_strainphlan_input.xlsx')
View(spp)
# clean the format of the spp
dat <- read_tsv('~/Work/projects/IL22/data/metaphlan3/merged_abundance_table_metaphlan3.txt')
View(dat)
# clean the format of the spp
dat <- read_tsv('~/Work/projects/IL22/data/metaphlan3/merged_abundance_table_metaphlan3.txt', skip = 1)
dat
# clean the format of the spp
dat <- read_tsv('~/Work/projects/IL22/data/metaphlan3/merged_abundance_table_metaphlan3.txt', skip = 1) %>%
mutate(spp = str_extract(clade_name, 's__.+$'))
# clean the format of the spp
dat <- read_tsv('~/Work/projects/IL22/data/metaphlan3/merged_abundance_table_metaphlan3.txt', skip = 1) %>%
mutate(spp = str_extract(clade_name, 's__.+$')) %>%
select(spp)
# clean the format of the spp
dat <- read_tsv('~/Work/projects/IL22/data/metaphlan3/merged_abundance_table_metaphlan3.txt', skip = 1) %>%
mutate(spp = str_extract(clade_name, 's__.+$')) %>%
select(spp)
spp
spp <- readxl::read_excel('../data/top20_species_strainphlan_input.xlsx')  %>%
mutate(spp = str_replace_all(species, ' ', '_'))
spp
spp <- readxl::read_excel('../data/top20_species_strainphlan_input.xlsx')  %>%
mutate(spp = str_replace_all(species, ' ', '_')) %>%
mutate(spp = str_glue('s__{spp}'))
spp <- readxl::read_excel('../data/top20_species_strainphlan_input.xlsx')  %>%
mutate(spp = str_replace_all(species, ' ', '_')) %>%
mutate(spp = str_glue('s__{spp}')) %>%
select(spp) %>%
write_csv('../data/top20_spp.csv', col_names = F)
#Oct/22/2019
#
#Create username specific access to database in VDB lab.
#It removes the general `guest` account.
#
#
#Dropping user:
#  drop owned by test; drop role test; (https://stackoverflow.com/questions/9840955/postgresql-drop-role-fails-because-of-default-privileges)
#
#In order to set a new password, users need to run the following command:
#dbSendQuery(conn = con,"alter role YOUR_USERNAME password 'YOUR_PASSWORD'");
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# when there is request for new connection, add the new username to the list downbelow
# after the person changed the password, run this script again to unlock this user. then he should be good to go.
# (if the person doesn't change pw within 3 days), run :
#dbSendQuery(conn = con, "drop owned by <user>; drop role <user>")
#to drop the user
# (run this script and look down below to check who changed and who didn't  )
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
library(DBI)
source('create_new_postgres_user.R');
vdb_users <- c("peledj",
"burgosdm",
"slingerj",
"nguyenc1",
"daia1",
"miltiado",
"andrlovh",
"lindners",
"khann2",
"hatfielp",
"clurmana",
"adintorp",
"ngb",
"chens8",
"elkriefa",
"harfordl",
"jesusfar",
"crossj",
'funnellt',
"watersn",
"maclachlan",
"feit1",
"MarcellL",
'sadeghik',
"rajs");
#               "gomesa_cluster");
collaboration_users <- c("shouvalr",
"lesokhia",
"rollingt",
"chowelld",
"krishnac");
#temporary_pw=my.name <- readline(prompt="Enter temporary password: ")
temporary_pw='test123456';
vdb_and_collaborator_users <- c(vdb_users,
collaboration_users);
#stop("Stopping before creating user");
for(i in 1:length(vdb_and_collaborator_users)){
create_new_postgres_user(vdb_and_collaborator_users[i],temporary_pw);
}
cat("\n\n")
#create_new_postgres_user(vdb_users[length(vdb_users)],temporary_pw);
#dbDisconnect(con)
if(1){
#Run this part to remove passwords!
for(i in 1:length(vdb_and_collaborator_users)){
block_user_who_did_not_change_password(vdb_and_collaborator_users[i],
temporary_pw)
}
}
#block_user_who_did_not_change_password(vdb_users[length(vdb_users)],temporary_pw);
