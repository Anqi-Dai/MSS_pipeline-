---
title: "CCA"
author: "Anqi Dai"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
```

```{r}
library(tidyverse)
library(vegan)
library(ggpubr)
```


Now that we’ve created our matrix it is usually a good idea to make sure everything looks ok - the row and column sums (i.e., marginal sums) provide one reasonable metric to see overall how the data is structured in a very coarse way.

**Assumptions**

Response variables show unimodal distributions across objects. If dealing with a sites × species (or OTUs) matrix, this suggests that a sampling gradient must be long enough to allow the increase and decrease of a given species or OTU across the sites sampled. Gradients that are too short may manifest linear responses and may be better handled by redundancy analysis (RDA), although CCA may also handle linear relationships.
Explanatory variables show linear, causal relationships to the response data. If one is unsure if their is a causal relationship between an explanatory variable and the response data, interpretation should be performed with care.

**Warnings**

The variables in the explanatory matrix should be chosen with care, i.e. there should be good rationale behind their inclusion. If explanatory variables are included too liberally, there is an increased risk of distorting the resulting CCA results.
Only examine the significance and effects of individual axes if the overall CCA solution is found to be significant.
The algorithm used to compute a CCA solution and the exact meaning of the scaling modes may vary across implementations. Carefully review how results should be interpreted in each implementation used.

## Data preparation 

```{r}
pair3 <- read_csv('../data/finalized/paired/pair_p3day_food_level2_res_fil.csv')

# load the cts_all_fil these are the qualified samples genus relab for the genus that have relab > 0.001 in >= 10% of samples
cts_all_fil <- read_csv('../data/finalized/paired/pair_p3day_qualified_stool_sampled_family_relab.csv')

cts_all_fil %>% 
  ungroup() %>% 
  distinct(taxa_family)

N <- 30

source('~/db_connect_simple.R')
connect_database(config_file = '~/dbConfig.txt')
get_table_from_database('asv_annotation_blast_ag')

# keep the top 30 cuz cca can't allow too many features at a time
cts_all_top_family <- cts_all_fil %>% 
  group_by(taxa_family) %>% 
  summarise(sum_relab = sum(relab)) %>% 
  top_n(n = N, wt = sum_relab) %>% 
  pull(taxa_family)


asv_counts_ag <- read_csv('../data/asv_counts_ag_Feb17.csv')
# get the top features count matrix in raw count
cts <- asv_counts_ag %>% 
  filter(sampleid %in% pair3$sampleid) %>% 
  select(asv_key, sampleid, count) %>% 
  spread(key = 'sampleid', value = 'count', fill = 0) %>% 
  arrange(asv_key)  

annot <- asv_annotation_blast_ag %>% 
  filter(asv_key %in% cts$asv_key) %>% 
  mutate(ordr =  if_else(ordr == '', str_glue('of_class_{class}'), ordr),
         family =  if_else(family == '', str_glue('of_order_{ordr}'), family),
         genus =  if_else(genus == '', str_glue('of_family_{family}'), genus),
         species =  if_else(species == '', str_glue('of_genus_{genus}'), species)) %>% 
  mutate(taxa_family = str_glue('k__{kingdom}|p__{phylum}|c__{class}|o__{ordr}|f__{family}'))


# replace the asv_key with the genus taxa level
# summarize from asv level to genus level
# get the relative abundance for the genera
cts_raw_top <- cts %>% 
  full_join(annot %>%  select(asv_key, taxa_family), by  = 'asv_key') %>% 
  select(-asv_key) %>% 
  gather(key = 'sampleid', value = 'count', names(.)[1]:names(.)[ncol(.) - 1]) %>% 
  group_by(sampleid, taxa_family) %>% 
  summarise(cnt = sum(count)) %>% 
  filter(taxa_family %in% cts_all_top_family) %>% 
  spread(key = 'sampleid', value = 'cnt') %>% 
  mutate(taxa_family = str_extract(taxa_family, 'f__.+$'),
         taxa_family = str_replace(taxa_family, 'f__','')) %>% 
  filter(taxa_family!='NA') %>% 
  gather(key = 'sampleid', value = 'cnt', names(.)[2]:names(.)[ncol(.)]) %>% 
  spread(key = 'taxa_family', value = 'cnt') %>% 
  arrange(sampleid) %>% 
  column_to_rownames('sampleid')
  
```

```{r}
# the env(meta data )
meta <- read_tsv('../data/finalized/meta_data_67.tsv')

# pair3 %>% 
#   distinct(mrn , sampleid) %>% 
#   count(mrn)

# key info of the patients as the meta
ptinfo <- meta %>% 
  distinct(mrn, intensity, source, age_at_hsct, sex, admit_bmi)

# the table that also has nutrients data
both_metric <- read_csv('../data/finalized/paired/pair_p3day_food_group_n_nutrients_res.csv') 

pheno <-  both_metric %>% 
  filter(str_detect(type, '_total$')) %>% 
  # include only the qualified samples
  filter(sampleid %in% rownames(cts_raw_top)) %>% 
  ungroup() %>% 
  spread(key = 'type', value = 'ave_type', fill = 0) %>% 
  left_join(ptinfo, by = 'mrn') %>% 
  mutate(intensity = factor(intensity),
         source = factor(source),
         sex = factor(sex)) %>% 
  # sort the sampleid
  arrange(sampleid) %>% 
  select(-mrn) %>% 
  column_to_rownames('sampleid') %>% 
  # remove the total in the column names 
  rename_all(funs(str_replace(., '_total$','') ))
```

```{r}
# square root transformation
cts_sqrt_top <- sqrt(cts_raw_top)
```


## CCA

- CCA is appropriate for modeling unimodal or hump-shaped responses to explanatory variables (rather than linear as with RDA).
- Inertia is another name for variation or variance in this case. “Total” refers to total variance, “Constrained” refers to the amount of variance explained by the explanatory variables, “Unconstrained” refers to the residual variance. Constrained + Unconstrained = Total. 

### Diet--food groups

```{r}
nutrients_names <- data_frame(
  colname = colnames(pheno)
) %>% 
  filter(str_detect(colname, "^[:upper:]")) %>% 
  pull(colname)


pheno1 <- pheno %>% 
  select(-all_of(nutrients_names))
  
```

#### The model

```{r}
set.seed(123)
pair3.cca <- cca(cts_sqrt_top ~ ., pheno1) 
summary(pair3.cca)
screeplot(pair3.cca)
# VIFs
vif.cca(pair3.cca)

# should remove source probably correlate with intensity
pheno2 <- pheno1 %>% 
  select(-source)

pair3.cca2 <- cca(cts_sqrt_top ~ ., pheno2) 
vif.cca(pair3.cca2)
```
```{r}
summary(pair3.cca2) 
pair3.cca2
screeplot(pair3.cca2)# this is plotting the Eigenvalues for constrained axes
```

#### The visualization

**species or sp for species scores, sites or wa for site scores, lc for linear constraints or ``LC scores'', or bp for biplot arrows or cn for centroids of factor constraints instead of an arrow.**

**As for CA, the species are shown as red crosses and samples as black circles**

**Each possible factor is plotted at the centroid of the samples on that type, shown as an "X". To find out which one is which, look at last element of the summary of the cca object.**

```{r}
# n stands for none just the frame
plot(pair3.cca2, display=c("species", "bp"), type="n", ylab="CCA2", main="Species", scaling="species")
text(pair3.cca2, display="species", col="black", scaling="species", cex = 0.5 )
text(pair3.cca2, display="bp", col="red", cex = 0.7)

# less milk and less sugar and less intense conditioning
```


Enterobacteriaceae are Gram-negative bacteria of a large family that includes Escherichia coli, Klebsiella, Salmonella, Shigella and Yersinia pestis. From: Saliva Protection and Transmissible Diseases, 2017.


The Enterococcaceae are a family of Gram-positive bacteria placed in the order Lactobacillales. Representative genera include Enterococcus, Melissococcus, Pilibacter, Tetragenococcus, and Vagococcus. In this family are some important lactic acid bacteria which produce lactic acid as the major metabolic end product.


### The statistical test

```{r}
# the whole model
anova(pair3.cca2, step=1000) 

# axis
anova(pair3.cca2, by="axis", step=1000) 

# individual predictors
anova.cca(pair3.cca2, step=1000, by="margin")

pair3.cca2_margin <- anova.cca(pair3.cca2, step=1000, by="margin")

pair3.cca2_margin_pval <- pair3.cca2_margin %>% 
  rownames_to_column('predictor') %>% 
  rename(pval = names(.)[ncol(.)]) %>% 
  filter(!is.na(pval)) %>% 
  mutate(fdr = p.adjust(pval, method = 'BH')) %>% 
  arrange(fdr)


pair3.cca2_margin_pval
#cca.step.forward <- ordistep(cca(cts_sqrt_top ~ 1, data=pheno2),scope=formula(pair3.cca2), direction="forward",pstep=1000) # remove legume_total
```


